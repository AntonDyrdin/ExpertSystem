если target_function=accuracy/stdDev, то оптимизация приводит к тому, что сеть не выдаёт ничего кроме 0,5 на выходе

После включения цикл оптимизации обучения (а потом и сортировки) потенциально оптимальных индивидов (у которых индекс меньше elite_ratio*population_value), было обнаружено, что их значения критерия оптимальности(КО) не воспроизводятся после повторного обучения (и вычисления (КО)), из-за чего они снова получают индекс, при котором их гиперараметры подвергаются модификации, после чего они с ещё большей вероятностью получают низкие значения критерия оптимальности.
Таким образом весь алгоритм не сходится, а дёргается в сторону оптимума, постоянно возвращаясь к началу. Процесс оптимизации при этом выглядит случайным. Локальные оптимумы так же не наблюдаются.
В связи с этим, вводится многократное вычисление критерия оптимальности, с целью повышения повторяемости результатов, методом усреднения полученного массива значений.


Увеличение размера популяции до 90 индивидов так же привело к сходимости алгоритма.

Можно попробовать сравнить результаты прогнозирования с наивной стратегией s(i+1)=s;

Добавить алгоритм с максимально гибкой структурой

Провести эксперименты с датасетом, собранном из нескольких индикаторов. В том числе попробовать производить торговлю без прогнозирования (используя только SARSA алгоритм).

После добавления нового алгоритма его нужно добавить в код чтения параметров эксперта [Expert.cs - строка 696]

При оптимизации с включенным многопотоком возникают проблемы, если перемещение файлов не удалось

вывести нормализацию в скрипт

Если сгладить временной ряд скользящим средним, то точность прогноза на следующий шаг возрастает лишь 
за счёт того, что знак относительного приращения [Ts(i)-Ts(i-1)] повторяется несколько раз подряд, 
а не скачет туда-сюда. Возможно, установив в качестве прогнозируемого шага, шаг Ts(i+n), где
n>1 сеть перестанет цепляться за последнее значение Ts(i), но тогда это ещё больше снизит точность.

1) реализовать советника MT5 на основе алгортма SARSA и использовании максимального количества предикторов и параметров состояния.

2) запустить оптимизацию на мультидатасете и минутных/часовых таймфреймах.

Одномерная свёртка:
modelC.add(Conv1D(50, 5, input_shape = (xTrain.shape[1], xTrain.shape[2]), activation="linear"))
modelC.add(Flatten())
modelC.add(Dense(10, activation="linear"))
modelC.add(Dense(yTrain.shape[1], activation="linear"))
modelC.compile(loss="mse", optimizer=Adam(lr=1e-4))
history = modelC.fit(xTrain, 
                    yTrain, 
                    epochs=20, 
                    batch_size=20, 
                    verbose=1,
                    validation_data=(xVal, yVal))